import itertools
import multiprocessing as mp

from dataclasses import asdict
from functools import partial
from pathlib import Path
from typing import List

import click

from iohub.ngff import Plate, Position, open_ome_zarr
from natsort import natsorted

from mantis.cli import utils
from mantis.analysis.AnalysisSettings import DeskewSettings
from mantis.analysis.deskew import deskew_data, get_deskewed_data_shape
from mantis.cli.parsing import (
    deskew_param_argument,
    input_data_paths_argument,
    output_dataset_options,
)
import yaml


# TODO: consider refactoring to utils
def deskew_params_from_file(deskew_param_path: Path) -> DeskewSettings:
    """Parse the deskewing parameters from the yaml file"""
    # Load params
    with open(deskew_param_path) as file:
        raw_settings = yaml.safe_load(file)
    settings = DeskewSettings(**raw_settings)
    click.echo(f"Deskewing parameters: {asdict(settings)}")
    return settings


def deskew_zyx_and_save(
    position: Position, output_path: Path, settings: DeskewSettings, t_idx: int, c_idx: int
) -> None:
    """Load a zyx array from a Position object, deskew it, and save the result to file"""
    click.echo(f"Deskewing c={c_idx}, t={t_idx}")
    zyx_data = position[0][t_idx, c_idx]

    # Deskew
    deskewed = deskew_data(
        zyx_data, settings.ls_angle_deg, settings.px_to_scan_ratio, settings.keep_overhang
    )
    # Write to file
    with open_ome_zarr(output_path, mode="r+") as output_dataset:
        output_dataset[0][t_idx, c_idx] = deskewed
        output_dataset.zattrs["deskewing"] = asdict(settings)

    click.echo(f"Finished Writing.. c={c_idx}, t={t_idx}")


def deskew_single_position(
    input_data_path: Path,
    output_path: Path = './deskewed.zarr',
    deskew_param_path: Path = './deskew_setting.yml',
    num_processes: int = mp.cpu_count(),
) -> None:
    """Deskew a single position with multiprocessing parallelization over T and C"""

    # Get the reader and writer
    click.echo(f'Input data path:\t{input_data_path}')
    click.echo(f'Output data path:\t{str(output_path)}')
    input_dataset = open_ome_zarr(str(input_data_path))
    click.echo(input_dataset.print_tree())

    settings = deskew_params_from_file(deskew_param_path)
    T, C, Z, Y, X = input_dataset.data.shape
    click.echo(f'Dataset shape:\t{input_dataset.data.shape}')

    # Loop through (T, C), deskewing and writing as we go
    click.echo(f"Starting multiprocess pool with {num_processes} processes")
    with mp.Pool(num_processes) as p:
        p.starmap(
            partial(deskew_zyx_and_save, input_dataset, str(output_path), settings),
            itertools.product(range(T), range(C)),
        )


@click.command()
@input_data_paths_argument()
@deskew_param_argument()
@output_dataset_options(default="./deskewed.zarr")
@click.option(
    "--num-processes",
    "-j",
    default=mp.cpu_count(),
    help="Number of cores",
    required=False,
    type=int,
)
def deskew(
    input_paths: List[str], deskew_param_path: str, output_path: str, num_processes: int
):
    "Deskews a single position across T and C axes using a parameter file generated by estimate_deskew.py"
    if isinstance(open_ome_zarr(input_paths[0]), Plate):
        raise ValueError(
            "Please supply a single position instead of an HCS plate. Likely fix: replace input.zarr with 'input.zarr/0/0/0'"
        )

    # Sort the input as nargs=-1 will not be natsorted
    input_paths = [Path(path) for path in natsorted(input_paths)]

    # Convert string paths to Path objects
    output_path = Path(output_path)
    deskew_param_path = Path(deskew_param_path)

    # Handle single position or wildcard filepath
    output_paths = utils.get_output_paths(input_paths, output_path)
    click.echo(f'List of input_pos:{input_paths} output_pos:{output_paths}')

    # Get the deskewing parameters
    # Load the first position to infer dataset information
    with open_ome_zarr(str(input_paths[0]), mode="r") as input_dataset:
        T, C, Z, Y, X = input_dataset.data.shape
        settings = deskew_params_from_file(deskew_param_path)
        deskewed_shape, voxel_size = get_deskewed_data_shape(
            (Z, Y, X),
            settings.ls_angle_deg,
            settings.px_to_scan_ratio,
            settings.keep_overhang,
            settings.pixel_size_um,
        )

        # Create a zarr store output to mirror the input
        utils.create_empty_zarr(
            input_paths,
            output_path,
            output_zyx_shape=deskewed_shape,
            chunk_zyx_shape=deskewed_shape,
            voxel_size=voxel_size,
        )

    deskew_args = {
        'ls_angle_deg': settings.ls_angle_deg,
        'px_to_scan_ratio': settings.px_to_scan_ratio,
        'keep_overhang': settings.keep_overhang,
    }
    # Loop over positions
    for input_position_path, output_position_path in zip(input_paths, output_paths):
        utils.process_single_position(
            deskew_zyx_and_save,
            input_data_path=input_position_path,
            output_path=output_position_path,
            deskew_param_path=deskew_param_path,
            num_processes=num_processes,
            **deskew_args,
        )
